library(lme4)
library(afex)
library(brms)
library(arm)
library(tidyverse)
library(jtools)
library(interactions)

# writeLines(capture.output(sessionInfo()), "sessionInfo.txt")

d <- read_csv("data/merged_data.csv")

d <- d %>%
  filter(time_period %in% 2015:2021) %>%
  select(new_la_code, time_period, la_name, at31_cin_ep_rate_10000, cpp_start_rate10000, at_31_cla_rate10000, cla_start_rate10000, rel_pov_rate100, gspend_noncla_nonsg_pc, median_gppa_adj) %>%
  mutate(
    time_period = time_period - 2015
  )

# complete cases (for now) but data imputation later
d <- d[complete.cases(d),]

# Slope-slope models and regression of residuals
cla_trends <- lmer(data = d, at_31_cla_rate10000 ~ time_period + (time_period | new_la_code))
pov_trends <- lmer(data = d, rel_pov_rate100 ~ time_period + (time_period | new_la_code))
spend_trends <- lmer(data = d, gspend_noncla_nonsg_pc ~ time_period + (time_period | new_la_code))
gppa_trends <- lmer(data = d, median_gppa_adj ~ time_period + (time_period | new_la_code))
cla_start_trends <- lmer(data = d, cla_start_rate10000 ~ time_period + (time_period | new_la_code))
cpp_trends <- lmer(data = d, cpp_start_rate10000 ~ time_period + (time_period | new_la_code))
cin_trends <- lmer(data = d, at31_cin_ep_rate_10000 ~ time_period + (time_period | new_la_code))

# Get country-level random intercepts and random slopes for cla, poverty, and spend trends
cla_trend_res <- as_tibble(ranef(cla_trends, condVar = TRUE)) %>%
                  select(term, new_la_code = grp, re = condval, re_sd = condsd) %>%
                  pivot_wider(names_from = term, values_from = c(re, re_sd)) %>%
                  rename(re_cla_intercept = 2, re_cla_slope = 3, resd_cla_intercept = 4, resd_cla_slope = 5)

pov_trend_res <- as_tibble(ranef(pov_trends, condVar = TRUE)) %>%
                  select(term, new_la_code = grp, re = condval, re_sd = condsd) %>%
                  pivot_wider(names_from = term, values_from = c(re, re_sd)) %>%
                  rename(re_pov_intercept = 2, re_pov_slope = 3, resd_pov_intercept = 4, resd_pov_slope = 5)

spend_trend_res <- as_tibble(ranef(spend_trends, condVar = TRUE)) %>%
                    select(term, new_la_code = grp, re = condval, re_sd = condsd) %>%
                    pivot_wider(names_from = term, values_from = c(re, re_sd)) %>%
                    rename(re_spend_intercept = 2, re_spend_slope = 3, resd_spend_intercept = 4, resd_spend_slope = 5)

gppa_trend_res <- as_tibble(ranef(gppa_trends, condVar = TRUE)) %>%
                    select(term, new_la_code = grp, re = condval, re_sd = condsd) %>%
                    pivot_wider(names_from = term, values_from = c(re, re_sd)) %>%
                    rename(re_gppa_intercept = 2, re_gppa_slope = 3, resd_gppa_intercept = 4, resd_gppa_slope = 5)

cla_start_trend_res <- as_tibble(ranef(cla_start_trends, condVar = TRUE)) %>%
                        select(term, new_la_code = grp, re = condval, re_sd = condsd) %>%
                        pivot_wider(names_from = term, values_from = c(re, re_sd)) %>%
                        rename(re_cla_start_intercept = 2, re_cla_start_slope = 3, resd_cla_start_intercept = 4, resd_cla_start_slope = 5)

cpp_trend_res <- as_tibble(ranef(cpp_trends, condVar = TRUE)) %>%
                  select(term, new_la_code = grp, re = condval, re_sd = condsd) %>%
                  pivot_wider(names_from = term, values_from = c(re, re_sd)) %>%
                  rename(re_cpp_intercept = 2, re_cpp_slope = 3, resd_cpp_intercept = 4, resd_cpp_slope = 5)

cin_trend_res <- as_tibble(ranef(cin_trends, condVar = TRUE)) %>%
                  select(term, new_la_code = grp, re = condval, re_sd = condsd) %>%
                  pivot_wider(names_from = term, values_from = c(re, re_sd)) %>%
                  rename(re_cin_intercept = 2, re_cin_slope = 3, resd_cin_intercept = 4, resd_cin_slope = 5)


# Join intercepts, slopes, standard errors together in the same dataset
intercepts_slopes <- left_join(cla_trend_res, pov_trend_res, by = "new_la_code") %>%
                        left_join(., spend_trend_res, by = "new_la_code") %>%
                        left_join(., gppa_trend_res, by = "new_la_code") %>%
                        left_join(., cla_start_trend_res, by = "new_la_code") %>%
                        left_join(., cpp_trend_res, by = "new_la_code") %>%
                        left_join(., cin_trend_res, by = "new_la_code")


# residuals
cla_resid <- resid(cla_trends)
pov_resid <- resid(pov_trends)
spend_resid <- resid(spend_trends)
gppa_resid <- resid(gppa_trends)
cla_start_resid <- resid(cla_start_trends)
cpp_resid <- resid(cpp_trends)
cin_resid <- resid(cin_trends)

# residuals from trends dataset
residuals_d <- tibble(new_la_code = d$new_la_code, 
                      time_period = d$time_period, 
                      cla_resid, 
                      pov_resid, 
                      spend_resid, 
                      gppa_resid,
                      cla_start_resid,
                      cpp_resid,
                      cin_resid)

# add level 2 intercept and slope values to residuals data
step2_d <- left_join(residuals_d, intercepts_slopes, by = "new_la_code")

# The residuals are effectively group mean centred and the intercepts and slopes are effectively grand mean centred
# grand mean of each
coef(summary(cla_trends))
coef(summary(pov_trends))
coef(summary(spend_trends))
coef(summary(gppa_trends))
coef(summary(cla_start_trends))
coef(summary(cpp_trends))
coef(summary(cin_trends))

ggplot(intercepts_slopes) +
  geom_point(aes(x = re_pov_slope, y = re_cla_slope))

ggplot(intercepts_slopes) +
  geom_point(aes(x = re_spend_slope, y = re_cla_slope))

ggplot(step2_d) +
  geom_point(aes(x = pov_resid, y = cla_resid))

ggplot(step2_d) +
  geom_point(aes(x = spend_resid, y = cla_resid))

ggplot(step2_d) +
  geom_point(aes(x = gppa_resid, y = cla_resid))


# NA the outlier spend slope

step2_d_or <- step2_d %>% 
  mutate(
    re_spend_slope = ifelse(re_spend_slope < -100, NA, re_spend_slope),
    cla_resid = ifelse(cla_resid < -23, NA, cla_resid)
  )

intercepts_slopes_or <- intercepts_slopes %>% 
  mutate(
    re_spend_slope = ifelse(re_spend_slope < -100, NA, re_spend_slope)
  )


# intercept-intercept model
lm(data = intercepts_slopes_or, re_cla_intercept ~ re_pov_intercept + re_spend_intercept + re_gppa_intercept) %>% summary()
lm(data = intercepts_slopes_or, re_cla_start_intercept ~ re_pov_intercept + re_spend_intercept + re_gppa_intercept) %>% summary()
lm(data = intercepts_slopes_or, re_cpp_intercept ~ re_pov_intercept + re_spend_intercept + re_gppa_intercept) %>% summary()
lm(data = intercepts_slopes_or, re_cin_intercept ~ re_pov_intercept + re_spend_intercept + re_gppa_intercept) %>% summary()


# slope-slope model
lm(data = intercepts_slopes_or, re_cla_slope ~ re_pov_slope + re_spend_slope + re_gppa_slope) %>% summary()
lm(data = intercepts_slopes_or, re_cla_start_slope ~ re_pov_slope + re_spend_slope + re_gppa_slope) %>% summary()
lm(data = intercepts_slopes_or, re_cpp_slope ~ re_pov_slope + re_spend_slope + re_gppa_slope) %>% summary()
lm(data = intercepts_slopes_or, re_cin_slope ~ re_pov_slope + re_spend_slope + re_gppa_slope) %>% summary()

# residual-residual model
rmod <- lmer(data = step2_d_or %>% mutate_at(vars(cla_resid, pov_resid, spend_resid, gppa_resid), scale), 
             cla_resid ~ lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + (0 + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) | new_la_code))

summary(rmod)
r_mod_res <- as_tibble(ranef(rmod)) %>%
  select(term, new_la_code = grp, re = condval, re_sd = condsd) %>%
  pivot_wider(names_from = term, values_from = c(re, re_sd)) %>%
  rename(lag_pov_re = 2, lag_spend_re = 3, lag_gppa_re = 4, lag_pov_resd = 5, lag_spend_resd = 6, lag_gppa_resd = 7)

# fixed effect coefficients
r_mod_fixef <- fixef(rmod)

r_mod_res


# residuals: CLA start
rmod_clastart <- lmer(data = step2_d_or %>% mutate_at(vars(cin_resid, cpp_resid, cla_start_resid, pov_resid, spend_resid, gppa_resid), scale), 
                      cla_start_resid ~ lag(cin_resid) + lag(cpp_resid) + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + (0 + lag(cin_resid) | new_la_code) + (0 + lag(cpp_resid) | new_la_code) + (0 + lag(pov_resid) | new_la_code) + (0 + lag(spend_resid) | new_la_code) + (0 + lag(gppa_resid) | new_la_code))

summary(rmod_clastart)

rmod_clastart <- lmer(data = step2_d_or %>% mutate_at(vars(cin_resid, cpp_resid, cla_start_resid, pov_resid, spend_resid, gppa_resid), scale), 
                      cla_start_resid ~ pov_resid + spend_resid + gppa_resid + 
                                       lag(cla_start_resid) + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + 
                                       (0 + pov_resid | new_la_code) + (0 + spend_resid | new_la_code) + (0 + gppa_resid | new_la_code) +
                                       (0 + lag(cla_start_resid) | new_la_code) + (0 + lag(pov_resid) | new_la_code) + (0 + lag(spend_resid) | new_la_code) + (0 + lag(gppa_resid) | new_la_code))

summary(rmod_clastart)


# residuals: CPP start
rmod_cpp <- lmer(data = step2_d_or %>% mutate_at(vars(cin_resid, cpp_resid, cla_start_resid, pov_resid, spend_resid, gppa_resid), scale), 
                      cpp_resid ~ lag(cpp_resid) + pov_resid + spend_resid + gppa_resid + 
                                  lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + 
                                  (0 + pov_resid | new_la_code) + (0 + spend_resid | new_la_code) + (0 + gppa_resid | new_la_code) +
                                  (0 + lag(cpp_resid) | new_la_code) + (0 + lag(pov_resid) | new_la_code) + (0 + lag(spend_resid) | new_la_code) + (0 + lag(gppa_resid) | new_la_code))

summary(rmod_cpp)



# residuals: CIN

rmod_cin <- lmer(data = step2_d_or %>% mutate_at(vars(cin_resid, cpp_resid, cla_start_resid, pov_resid, spend_resid, gppa_resid), scale), 
                 cin_resid ~ pov_resid + spend_resid + gppa_resid + 
                   lag(cin_resid) + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + 
                   (0 + pov_resid | new_la_code) + (0 + spend_resid | new_la_code) + (0 + gppa_resid | new_la_code) +
                   (0 + lag(cin_resid) | new_la_code) + (0 + lag(pov_resid) | new_la_code) + (0 + lag(spend_resid) | new_la_code) + (0 + lag(gppa_resid) | new_la_code))

summary(rmod_cin)


# add referrals to data?


# Bayesian residuals-residuals model
step2_d_or_z <- step2_d_or %>% mutate_at(vars(cla_resid, cla_start_resid, pov_resid, spend_resid, gppa_resid), scale)

# set priors
rmod_priors <- get_prior(
  data = step2_d_or_z,
  formula = cla_resid ~ lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + (0 + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) | new_la_code)
)

# set weakly informative prior for all regression coefficients and intercepts
rmod_priors$prior[rmod_priors$class == "b"] <- "normal(0, 0.5)"
rmod_priors$prior[rmod_priors$class == "sd"] <- "student_t(3, 0, 1)"
rmod_priors$prior[rmod_priors$class == "Intercept"] <- "student_t(3, 0, 1)"
rmod_priors$prior[rmod_priors$class == "sigma"] <- "exponential(1)"

rmod_brm <- brm(data = step2_d_or_z,
                formula = cla_resid ~ lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + (0 + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) | new_la_code),
                warmup = 500, 
                iter = 2000,
                chains = 4,
                prior = rmod_priors,
                cores = 4)

summary(rmod_brm, prob = 0.89)

(-0.07 * 120/32.97655) * 3.897176 # Â£120 increase above trend in the previous year associated with ~1 fewer child in care per 10,000

# Get random effects for each variable and tidy them up, with 89% credible intervals

quantile_range = c(0.1, 0.9)

pov_ranefs <- as_tibble(as.data.frame(brms::ranef(rmod_brm, probs = quantile_range, pars = "lagpov_resid", groups = "new_la_code", robust = TRUE)) %>% rownames_to_column() ) %>%
  rename(new_la_code = 1, lagpov_re = 2, lagpov_rese = 3, lagpov_re_q80lb = 4, lagpov_re_q80ub = 5)

spend_ranefs <- as_tibble(as.data.frame(brms::ranef(rmod_brm, probs = quantile_range, pars = "lagspend_resid", groups = "new_la_code", robust = TRUE)) %>% rownames_to_column() ) %>%
  rename(new_la_code = 1, lagspend_re = 2, lagspend_rese = 3, lagspend_re_q80lb = 4, lagspend_re_q80ub = 5)

gppa_ranefs <- as_tibble(as.data.frame(brms::ranef(rmod_brm, probs = quantile_range, pars = "laggppa_resid", groups = "new_la_code", robust = TRUE)) %>% rownames_to_column() ) %>%
  rename(new_la_code = 1, laggppa_re = 2, laggppa_rese = 3, laggppa_re_q80lb = 4, laggppa_re_q80ub = 5)

rmod_brm_res <- left_join(pov_ranefs, spend_ranefs, by = "new_la_code") %>%
  left_join(gppa_ranefs, by = c("new_la_code"))


# get fixed/population effects
rmod_brm_fes <- as_tibble(brms::fixef(rmod_brm) %>% as.data.frame() %>% rownames_to_column())

fe_lagspend <- rmod_brm_fes[rmod_brm_fes$rowname == "lagspend_resid", "Estimate"][[1]]
fe_lagpov <- rmod_brm_fes[rmod_brm_fes$rowname == "lagpov_resid", "Estimate"][[1]]
fe_laggppa <- rmod_brm_fes[rmod_brm_fes$rowname == "laggppa_resid", "Estimate"][[1]]

ggplot(rmod_brm_res) +
  geom_segment(aes(x = rank(lagspend_re), xend = rank(lagspend_re),
                   y = lagspend_re_q80lb + fe_lagspend, yend = lagspend_re_q80ub + fe_lagspend)) +
  geom_point(aes(x = rank(lagspend_re), y = lagspend_re + fe_lagspend))

ggplot(rmod_brm_res) +
  geom_segment(aes(x = rank(lagpov_re), xend = rank(lagpov_re),
                   y = lagpov_re_q80lb + fe_lagpov, yend = lagpov_re_q80ub + fe_lagpov)) +
  geom_point(aes(x = rank(lagpov_re), y = lagpov_re + fe_lagpov))

ggplot(rmod_brm_res) +
  geom_segment(aes(x = rank(laggppa_re), xend = rank(laggppa_re),
                   y = laggppa_re_q80lb + fe_laggppa, yend = laggppa_re_q80ub + fe_laggppa)) +
  geom_point(aes(x = rank(laggppa_re), y = laggppa_re + fe_laggppa))

# residuals-residuals bayesian model with cla_start
# set priors

rmod_formula <- bf(cla_start_resid ~ pov_resid + spend_resid + gppa_resid + 
                     lag(cla_start_resid) + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + 
                     (0 + pov_resid | new_la_code) + (0 + spend_resid | new_la_code) + (0 + gppa_resid | new_la_code) +
                     (0 + lag(cla_start_resid) | new_la_code) + (0 + lag(pov_resid) | new_la_code) + 
                     (0 + lag(spend_resid) | new_la_code) + (0 + lag(gppa_resid) | new_la_code), 
                   decomp = "QR")

rmod_start_priors <- get_prior(
  data = step2_d_or_z,
  formula = rmod_formula
)

# set weakly informative prior for all regression coefficients and intercepts
rmod_start_priors$prior[rmod_priors$class == "b"] <- "normal(0, 0.5)"
rmod_start_priors$prior[rmod_priors$class == "sd"] <- "student_t(3, 0, 1)"
rmod_start_priors$prior[rmod_priors$class == "Intercept"] <- "student_t(3, 0, 1)"
rmod_start_priors$prior[rmod_priors$class == "sigma"] <- "exponential(1)"

rmod_start_brm <- brm(data = step2_d_or_z,
                      formula = rmod_formula,
                      warmup = 500, 
                      iter = 3000,
                      chains = 4,
                      prior = rmod_start_priors,
                      cores = 4)

summary(rmod_start_brm, prob = 0.89)


# residuals-residuals bayesian model with cpp rate

as_tibble(as.data.frame(brms::ranef(rmod_start_brm, probs = quantile_range, pars = "lagspend_resid", groups = "new_la_code", robust = TRUE)) %>% rownames_to_column() ) %>%
  rename(new_la_code = 1, lagspend_re = 2, lagspend_rese = 3, lagspend_re_q80lb = 4, lagspend_re_q80ub = 5)

# get ranef draws for both lagspend_re and spend_re, add them together, then summarise with median, lb up
rmod_start_brm_draws <- as_draws_df(rmod_start_brm) %>% posterior::merge_chains()

names(rmod_start_brm_draws)

# Tidy draws so they can be summed
spend_res_combined <- rmod_start_brm_draws %>%
  sample_n(500) %>%
  select_at(vars(contains("spend_resid"))) %>%
  select_at(vars(contains("r_new_la_code"))) %>%
  pivot_longer(everything()) %>%
  separate(col = name, into = c("la_code", "effect"), sep = ",") %>%
  mutate(
    la_code = str_remove_all(la_code, "r_new_la_code\\["),
    effect = str_remove_all(effect, "\\]")
  ) %>% 
  group_by(la_code, effect) %>%
  mutate(iter = row_number()) %>%
  ungroup() %>%
  pivot_wider(values_from = value, names_from = "effect") %>%
  mutate(
    combined_spend_resid = spend_resid + lagspend_resid
  )

# calculate summary statistics for each local authority
spend_res_combined_sum <- spend_res_combined %>%
  group_by(la_code) %>%
  summarise_at(
    vars(spend_resid:combined_spend_resid),
    list(
      median = ~median(.),
      q89_lb = ~quantile(., 0.055),
      q89_ub = ~quantile(., 0.945)
    )
  )


# fixed effects
fixef_dat <- as_tibble(as.data.frame(fixef(rmod_start_brm)) %>% rownames_to_column())
c_spend_eff <- fixef_dat$Estimate[fixef_dat$rowname == "spend_resid"] + fixef_dat$Estimate[fixef_dat$rowname == "lagspend_resid"]

ggplot(spend_res_combined_sum) +
  geom_segment(aes(x = rank(combined_spend_resid_median), xend = rank(combined_spend_resid_median),
                   y = combined_spend_resid_q89_lb + c_spend_eff, yend = combined_spend_resid_q89_ub + c_spend_eff)) +
  geom_point(aes(x = rank(combined_spend_resid_median), y = combined_spend_resid_median + c_spend_eff)) +
  geom_hline(yintercept = c_spend_eff) +
  theme_bw()

la_code_name_lu <- d %>% select(new_la_code, la_name) %>% group_by(new_la_code) %>% slice(1)

spend_res_combined_sum <- left_join(spend_res_combined_sum, la_code_name_lu, by = c("la_code" = "new_la_code")) %>%
  relocate(la_name, .after = la_code)

# ifelse for if LA names are selected

spe_combined_plot <- spend_res_combined_sum %>%
  mutate(rank_cspend = rank(combined_spend_resid_median)) %>%
  ggplot() +
  geom_hline(yintercept = c_spend_eff) +
  geom_segment(aes(x = rank_cspend, xend = rank_cspend,
                   y = combined_spend_resid_q89_lb + c_spend_eff, yend = combined_spend_resid_q89_ub + c_spend_eff)) +
  geom_point(aes(x = rank_cspend, y = combined_spend_resid_median + c_spend_eff, text = la_name)) +
  # geom_segment(data = . %>% filter(la_name %in% c("c")),
  #                aes(x = rank_cspend, xend = rank_cspend,
  #                y = combined_spend_resid_q89_lb + c_spend_eff, yend = combined_spend_resid_q89_ub + c_spend_eff), col = "turquoise") +
  # geom_point(data = . %>% filter(la_name %in% c("")),
  #            aes(x = rank_cspend, y = combined_spend_resid_median + c_spend_eff, text = la_name), col = "turquoise") +
  theme_bw()


# long run effect/long run propensity of spending residuals - summing the weights

plotly::ggplotly(spe_combined_plot, tooltip = "text")

write_csv(spend_res_combined_sum, "data/spend_REs_LRPs.csv")

# slope-slope model with measurement error

slopes_or_d <- intercepts_slopes_or %>%
  # make spending per 100
  mutate_at(vars(re_spend_slope, resd_spend_slope), ~./100) %>%
  # make income per 1000
  mutate_at(vars(re_gppa_slope, resd_gppa_slope), ~./1000) 

s_formula <- bf(re_cla_slope | resp_se(resd_cla_slope, sigma = TRUE) ~ 
                  me(re_pov_slope, resd_pov_slope) + 
                  me(re_spend_slope, resd_spend_slope) + 
                  me(re_gppa_slope, resd_gppa_slope))


# set priors
smod_priors <- get_prior(
  data = slopes_or_d,
  formula = s_formula
)

smod_priors

# set weakly informative prior for all regression coefficients and slopes
smod_priors$prior[smod_priors$class == "b" & smod_priors$coef == "mere_gppa_sloperesd_gppa_slope"] <- "normal(0, 3)"
smod_priors$prior[smod_priors$class == "b" & smod_priors$coef == "mere_pov_sloperesd_pov_slope"] <- "normal(0, 3)"
smod_priors$prior[smod_priors$class == "b" & smod_priors$coef == "mere_spend_sloperesd_spend_slope"] <- "normal(0, 3)"

smod_brm <- brm(data = slopes_or_d,
                formula = s_formula,
                warmup = 500, 
                iter = 2000,
                chains = 4,
                prior = smod_priors,
                cores = 4)

summary(smod_brm)

pov_ce <- conditional_effects(smod_brm, effects = "re_pov_slope",
                    prob = 0.89, robust = TRUE, points = TRUE, ndraws = 1000) 

la_code_name_lu <- d %>% select(new_la_code, la_name) %>% group_by(new_la_code) %>% slice(1)
# Add LA codes and names to points attribute
attributes(pov_ce$re_pov_slope)$points <- left_join(bind_cols(new_la_code = slopes_or_d$new_la_code, attributes(pov_ce$re_pov_slope)$points), la_code_name_lu, by = "new_la_code")

pred_data_pov <- pov_ce$re_pov_slope
points_dat_pov <- attributes(pov_ce$re_pov_slope)$points

# plot and highlight LA of interest
plot(pov_ce, points = TRUE, plot = FALSE, 
     point_args = list(alpha = 0.4, size = 2))[[1]] 

# Baseline for plot for specific cities - requires premade pred_data and points_dat from conditional effects

pred_data_pov %>%
  ggplot() +
  geom_ribbon(aes(x = re_pov_slope, ymin = lower__, ymax = upper__), alpha = 0.2) +
  geom_line(aes(x = re_pov_slope, y = estimate__)) +
  geom_point(data = points_dat_pov, aes(x = re_pov_slope, y = resp__), alpha = 0.6) +
  geom_point(data = points_dat_pov %>% filter(la_name %in% c("Sheffield", "Birmingham", "Leeds")), 
             aes(x = re_pov_slope, y = resp__), alpha = 1, col = "turquoise") +
  ggrepel::geom_text_repel(
    data = points_dat_pov %>% filter(la_name %in% c("Sheffield", "Birmingham", "Leeds")), 
    aes(x = re_pov_slope, y = resp__, label = la_name), alpha = 1
  ) +
  theme_minimal()
  
  
spend_ce <- conditional_effects(smod_brm, effects = "re_spend_slope",
                                prob = 0.89, robust = TRUE, points = TRUE, ndraws = 1000) 

attributes(spend_ce$re_spend_slope)$points <- left_join(bind_cols(new_la_code = slopes_or_d$new_la_code, attributes(spend_ce$re_spend_slope)$points), la_code_name_lu, by = "new_la_code")
pred_data_spend <- spend_ce$re_spend_slope
points_dat_spend <- attributes(spend_ce$re_spend_slope)$points

pred_data_spend %>%
  ggplot() +
  geom_ribbon(aes(x = re_spend_slope, ymin = lower__, ymax = upper__), alpha = 0.2) +
  geom_line(aes(x = re_spend_slope, y = estimate__)) +
  geom_point(data = points_dat_spend, aes(x = re_spend_slope, y = resp__), alpha = 0.6) +
  geom_point(data = points_dat_spend %>% filter(la_name %in% c("Sheffield", "Birmingham", "Leeds")), 
             aes(x = re_spend_slope, y = resp__), alpha = 1, col = "turquoise") +
  ggrepel::geom_text_repel(
    data = points_dat_spend %>% filter(la_name %in% c("Sheffield", "Birmingham", "Leeds")), 
    aes(x = re_spend_slope, y = resp__, label = la_name), alpha = 1
  ) +
  theme_minimal()






# Intercept-intercept model with measurement error

intercepts_slopes_or_d <- intercepts_slopes_or %>%
  # make spending per 100
  mutate_at(vars(re_spend_intercept, resd_spend_intercept), ~./100) %>%
  # make income per 1000
  mutate_at(vars(re_gppa_intercept, resd_gppa_intercept), ~./1000) 

i_formula <- bf(re_cla_intercept | resp_se(resd_cla_intercept, sigma = TRUE) ~ 
                  me(re_pov_intercept, resd_pov_intercept) + 
                  me(re_spend_intercept, resd_spend_intercept) + 
                  me(re_gppa_intercept, resd_gppa_intercept))


# set priors
imod_priors <- get_prior(
  data = intercepts_slopes_or_d,
  formula = i_formula
)

imod_priors

# set weakly informative prior for all regression coefficients and intercepts
imod_priors$prior[imod_priors$class == "b" & imod_priors$coef == "mere_gppa_interceptresd_gppa_intercept"] <- "normal(-5, 20)"
imod_priors$prior[imod_priors$class == "b" & imod_priors$coef == "mere_pov_interceptresd_pov_intercept"] <- "normal(10, 20)"
imod_priors$prior[imod_priors$class == "b" & imod_priors$coef == "mere_spend_interceptresd_spend_intercept"] <- "normal(0, 25)"

imod_brm <- brm(data = intercepts_slopes_or_d,
                formula = i_formula,
                warmup = 500, 
                iter = 2000,
                chains = 4,
                prior = imod_priors,
                cores = 4)

summary(imod_brm)

pov_ce_i <- conditional_effects(imod_brm, effects = "re_pov_intercept",
                                prob = 0.89, robust = TRUE, points = TRUE, ndraws = 1000) 



attributes(pov_ce_i$re_pov_intercept)$points <- left_join(bind_cols(new_la_code = intercepts_slopes_or_d$new_la_code, attributes(pov_ce_i$re_pov_intercept)$points), la_code_name_lu, by = "new_la_code")
pred_data_pov_ce_i <- pov_ce_i$re_pov_intercept
points_dat_pov_ce_i <- attributes(pov_ce_i$re_pov_intercept)$points

pred_data_pov_ce_i %>%
  ggplot() +
  geom_ribbon(aes(x = re_pov_intercept, ymin = lower__, ymax = upper__), alpha = 0.2) +
  geom_line(aes(x = re_pov_intercept, y = estimate__)) +
  geom_point(data = points_dat_pov_ce_i, aes(x = re_pov_intercept, y = resp__), alpha = 0.6) +
  geom_point(data = points_dat_pov_ce_i %>% filter(la_name %in% c("Sheffield", "Birmingham", "Leeds")), 
             aes(x = re_pov_intercept, y = resp__), alpha = 1, col = "turquoise") +
  ggrepel::geom_text_repel(
    data = points_dat_pov_ce_i %>% filter(la_name %in% c("Sheffield", "Birmingham", "Leeds")), 
    aes(x = re_pov_intercept, y = resp__, label = la_name), alpha = 1
  ) +
  theme_minimal()





# ----------- Interactions for LA variation


# 90% CIs
ggplot(r_mod_res) +
  geom_segment(aes(x = rank(lag_spend_re), xend = rank(lag_spend_re), 
                   y = (lag_spend_re - 1.28*lag_spend_resd) + r_mod_fixef["lag(spend_resid)"],
                   yend = (lag_spend_re + 1.28*lag_spend_resd) + r_mod_fixef["lag(spend_resid)"])
  ) +
  geom_point(aes(x = rank(lag_spend_re), y = lag_spend_re + r_mod_fixef["lag(spend_resid)"])) 


# Interaction model 
rmod <- lmer(data = step2_d_or %>% mutate(cla_resid = scale(cla_resid)) %>% mutate_at(vars(pov_resid, spend_resid, gppa_resid), ~lag(scale(.))), 
             cla_resid ~ pov_resid * spend_resid + gppa_resid + (0 + pov_resid + spend_resid + gppa_resid | new_la_code))

summary(rmod) # in higher poverty residual LAs, higher lagged spending residuals are associated with lower CLA rates the following year

intslopes <- sim_slopes(rmod, pred = spend_resid, modx = pov_resid, modx.values = c(-2, -1, 0, 1, 2), johnson_neyman = TRUE)
plot(intslopes) # spending on preventative services most effective in poorest places

# Interaction model - Bayesian







#--- to export for shiny app example:

# Random effects from residual model
# conditional effects data from intercepts and slopes 

rmod_int_priors <- get_prior(
  data = step2_d_or_z,
  formula = cla_resid ~ lag(pov_resid) * lag(spend_resid) + lag(gppa_resid) + (0 + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) | new_la_code)
)

# set weakly informative prior for all regression coefficients and intercepts
rmod_int_priors$prior[rmod_int_priors$class == "b"] <- "normal(0, 0.5)"
rmod_int_priors$prior[rmod_int_priors$class == "sd"] <- "student_t(3, 0, 1)"
rmod_int_priors$prior[rmod_int_priors$class == "Intercept"] <- "student_t(3, 0, 1)"
rmod_int_priors$prior[rmod_int_priors$class == "sigma"] <- "exponential(1)"

rmod_int_brm <- brm(data = step2_d_or_z,
                formula = cla_resid ~ lag(pov_resid) * lag(spend_resid) + lag(spend_resid) * lag(gppa_resid) + (0 + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) | new_la_code),
                warmup = 500, 
                iter = 3000,
                chains = 4,
                prior = rmod_int_priors,
                cores = 4)

summary(rmod_int_brm)

conditions <- data.frame(pov_resid = setNames(c(-1, 0, 1), c("Low Poverty", "Average Poverty", "High Poverty")))
int_conde <- conditional_effects(rmod_int_brm, effects = "spend_resid", 
                                 conditions = conditions, robust = TRUE, ndraws = 1000, prob = 0.89)
  
int_pov_spe_data<- as_tibble(int_conde$spend_resid)

plot(int_conde)[[1]] 

# Interaction effect plot

int_pov_spe_data %>%
  mutate(
    pov_resid = recode_factor(factor(as.character(pov_resid), levels = c("-1", "0", "1")), `-1` = "-1SD", `0` = "Average", `1` = "+1SD")
  ) %>%
  ggplot() +
  geom_ribbon(aes(x = (spend_resid * 32.97655) + 8.774081e-14, 
                  ymin = (lower__ * 3.897176) + -1.113196e-13, 
                  ymax = (upper__ * 3.897176) + -1.113196e-13),
              fill = "grey75", col = "grey75", alpha = 0.5) + 
  geom_line(aes(x = (spend_resid * 32.97655) + 8.774081e-14, y = (estimate__ * 3.897176) + -1.113196e-13)) +
  facet_grid(cols = vars(pov_resid)) +
  scale_x_continuous(limits = c(-100, 100),
                     sec.axis = sec_axis(~., name = "1-year lagged Relative Child Poverty Residual\n", breaks = NULL, labels = NULL)) +
  scale_y_continuous(breaks = seq(-3, 3, 1), limits = c(-3, 3)) +
  ylab("Predicted Change in CLA Rate Residual (CLA per 10k)\n") +
  xlab("\n1-year lagged Preventative Spending Residual (per child)") +
  theme_bw()

int_pov_spe_data

# reverse engineer above plot

# interaction data
epre_dat <- tibble(spend_resid = rep(seq(-3, 3, length.out = 100), 3),
                   pov_resid = c(rep(-1, 100), rep(0, 100), rep(1, 100)),
                   gppa_resid = 0,
                   new_la_code = NA
                   )

predictions_dat <- brms::posterior_epred(rmod_int_brm, epre_dat, ndraws = 1000)

# Would need instead to not hold lagged spend constant for cumulative effect - should be able to use this method





# Distributed lag model

# Bayesian residuals-residuals model
step2_d_or_z <- step2_d_or %>% mutate_at(vars(cin_resid, cpp_resid, cla_resid, cla_start_resid, pov_resid, spend_resid, gppa_resid), scale)

# set priors
rmod_priors <- get_prior(
  data = step2_d_or_z,
  formula = cla_start_resid ~ pov_resid + spend_resid + gppa_resid + 
    lag(cla_start_resid) + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + 
    (0 + pov_resid | new_la_code) + 
    (0 + spend_resid | new_la_code) + 
    (0 + gppa_resid | new_la_code) +
    (0 + lag(cla_start_resid) | new_la_code) + 
    (0 + lag(pov_resid) | new_la_code) + 
    (0 + lag(spend_resid) | new_la_code) + 
    (0 + lag(gppa_resid) | new_la_code)
)

# set weakly informative prior for all regression coefficients and intercepts
rmod_priors$prior[rmod_priors$class == "b"] <- "normal(0, 0.5)"
rmod_priors$prior[rmod_priors$class == "sd"] <- "student_t(3, 0, 1)"
rmod_priors$prior[rmod_priors$class == "Intercept"] <- "student_t(3, 0, 1)"
rmod_priors$prior[rmod_priors$class == "sigma"] <- "exponential(1)"

rmod_brm <- brm(data = step2_d_or_z,
                formula = cla_start_resid ~ pov_resid + spend_resid + gppa_resid + 
                  lag(cla_start_resid) + lag(pov_resid) + lag(spend_resid) + lag(gppa_resid) + 
                  (0 + pov_resid | new_la_code) + 
                  (0 + spend_resid | new_la_code) + 
                  (0 + gppa_resid | new_la_code) +
                  (0 + lag(cla_start_resid) | new_la_code) + 
                  (0 + lag(pov_resid) | new_la_code) + 
                  (0 + lag(spend_resid) | new_la_code) + 
                  (0 + lag(gppa_resid) | new_la_code),
                warmup = 500, 
                iter = 2000,
                chains = 4,
                prior = rmod_priors,
                cores = 4)

summary(rmod_brm, prob = 0.89)

# cumulative effect of the independent variable

posterior::as_draws_df(rmod_brm) %>%
  posterior::merge_chains() %>%
  posterior::mutate_variables(b_cum_pov = b_pov_resid + b_lagpov_resid) %>%
  posterior::mutate_variables(b_cum_spend = b_spend_resid + b_lagspend_resid) %>%
  posterior::mutate_variables(b_cum_gppa = b_gppa_resid + b_laggppa_resid) %>%
  posterior::subset_draws(c("b_cum_pov", "b_cum_spend", "b_cum_gppa")) %>%
  posterior::summarise_draws(., median, ~quantile(.x, probs = c(0.055, 0.945)), posterior::rhat, posterior::ess_bulk)

# plotting combined simultaneous and lagged effect

# This gives the combined effect - it does not give the two separate effects
com_condeff <- conditional_effects(rmod_brm, effects = c("spend_resid"), 
                                   conditions = data.frame(spend_resid = c(-2,-1,0,1,2)), 
                                   robust = TRUE, ndraws = 1000, prob = 0.89)
com_condeff$spend_resid

# possible to get two separate effects? Probably need a separate model with lagged effect 
# as a new variable: lag transform in formula for a combined effect
epre_dat <- tibble(spend_resid = rep(seq(-3, 3, length.out = 100), 3),
                   pov_resid = c(rep(-1, 100), rep(0, 100), rep(1, 100)),
                   gppa_resid = 0,
                   new_la_code = NA
)

predictions_dat <- brms::posterior_epred(rmod_int_brm, epre_dat, ndraws = 1000)



# Export simpler model for Shiny example, then move this script over to fill project ipse



